<a href="https://www.twilio.com/blog/2013/04/add-two-factor-authentication-to-your-website-with-google-authenticator-and-twilio-sms.html/jf-2" rel="attachment wp-att-11918"><img class="alignright size-full wp-image-11918" src="https://www.twilio.com/blog/wp-content/uploads/2013/04/jf1.jpg" alt="jf" width="288" height="162" /></a><em>Since writing this post, we’ve created a new tutorial showing you how to <a href="https://www.twilio.com/docs/tutorials/walkthrough/sms-two-factor-authentication/ruby/rails">quickly add two-factor authentication to your applications</a> updated with some more recent techniques not highlighted below.</em>

<strong>Check out the newest TFA Tutorial <a href="https://www.twilio.com/docs/tutorials/walkthrough/two-factor-authentication/php/laravel">here</a></strong>
<h3>Why Two-Factor Authentication?</h3>
Back in the day, it used to be that enforcing a strong password policy was sufficient to prevent unauthorized access into your user's accounts. (Ah, those were the days, <a href="http://angg.twu.net/tourism.html">when kids were polite and respected their elders</a>). However, as the security landscape continues to evolve, it is becoming clear that a strong password policy is not enough any more. Today, an attacker can discover your user's password in a variety of ways: they might find your user's password on a stolen or lost computer, they might find their password on another site where your user used the same password, or your user's computer might be infected with a virus that is capturing their keystrokes.

In an ideal world, we would all be authenticating ourselves using tamper-proof hardware that implements a public-key cryptographic system. In the meantime, a simple and effective way of improving the way your users authenticate themselves is a method known as "<a href="http://www.twilio.com/solutions/two-factor-authentication">Two-Factor Authentication</a>", "Two-Factor Auth", or just "TFA". Two-Factor Authentication is a method where your users are required to log in with two "factors": a password, and a code from a device that they carry on their person. That device used to be a special-purpose device, but these days that device can just as well be a mobile phone.

A great pattern that we are seeing for implementing <a href="http://www.twilio.com/solutions/two-factor-authentication">two-factor authentication</a> is to use the TOTP (Time-based One-time Password Algorithm) standard for the second authentication step. What is so cool about TOTP is that it is flexible enough to allow your users to generate their authentication tokens directly on their smart phones using a TOTP app like <a href="http://support.google.com/accounts/bin/answer.py?hl=en&amp;answer=1066447">Google Authenticator</a> or have their tokens sent to their mobile phone via SMS.

This means that you only need to implement and test one additional authentication scheme, but get the benefits of having two different ways that your users can get tokens.

The best way to see how this is done is to look at some code. Let's do that now.

Here are the topics that I'll be covering:
<ol>
  <li><b>An Example of Application</b>
I will start with a very basic PHP/Laravel application that implements password authentication and build from there.</li>
  <li><b>Understanding TOTP</b>
Before I show you how to add TOTP to that example application, I'll explain how TOTP works.</li>
  <li><b>Adding Two-Factor Authentication</b>
Now that we know more about how TOTP works, I'll show you how to add it to the example application that we started with.</li>
  <li><b>Adding Google Authenticator</b>
Here I will show you how to enable your users to authenticate via the Google Authenticator.</li>
  <li><b>Adding Twilio</b>
Here I will show you how to enable your users to authenticate using a code that is delivered to their phone via SMS.</li>
  <li><b>Try It Out Yourself</b>
Finally, I give you a working example of a site that can use both the Google Authenticator and SMS to do two-factor authentication.</li>
</ol>
&nbsp;
<h3>An Example of An Application</h3>
Below is the code for a very basic website that only uses a username and password for authentication. We will start with this code, and then add two-factor authentication to it.

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/no-tfa/app/Http/routes.php">routes.php</a>:

[code language="php"]
<?php

Route::get('/', 'IndexController@getIndex');

Route::post('/', 'IndexController@login');

Route::get('/login', 'IndexController@getIndex');

Route::get('/user/', ['middleware' => 'auth', 'uses' => 'UserController@userPage']);

Route::get('/sign-up/', 'SignUpController@signUpPage');

Route::post('/sign-up/', 'SignUpController@signUp');

Route::get('/logout/', 'LogoutController@logout');
[/code]

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/no-tfa/app/Http/Controllers/IndexController.php">IndexController.php</a>:

[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Auth;
use App\Http\Requests;

class IndexController extends Controller
{
    public function getIndex()
    {
        return view('index');
    }

    public function login(Request $request)
    {
        $email = strtolower($request->input('email'));
        $password = $request->input('password');
        $isAuthenticated = Auth::attempt(['email' => $email, 'password' => $password]);

        if (!$isAuthenticated) {
            return view('index', ['errorMessage' => 'Incorrect Email or Password']);
        } else {
            return redirect()->intended('/user/');
        }
    }
}
[/code]

<a href="https://raw.githubusercontent.com/TwilioDevEd/blog-tfa-laravel/no-tfa/app/Http/Controllers/UserController.php">UserController.php</a>
[code language="php"]
<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Http\Requests;

class UserController extends Controller
{
    public function userPage()
    {
        return view('user');
    }
}
[/code]

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/no-tfa/app/Http/Controllers/SignUpController.php">SignUpController.php</a>
[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use DB;
use App\Http\Requests;
use Auth;

class SignUpController extends Controller
{
    public function signUpPage()
    {
        return view('signup');
    }

    public function signUp(Request $request)
    {
        $email = strtolower($request->input('email'));
        $password1 = $request->input('password1');
        $password2 = $request->input('password2');
        if ($password1 != $password2) {
            return view('signup', ['errorMessage' => 'Passwords do not match.']);
        } else {
            $users = DB::table('users')->where('email', $email)->get();
            if (!empty($users)) {
                return view('signup', ['errorMessage' => 'That email is already in use']);
            } else {
                $id = DB::table('users')->insertGetId(
                    ['email' => $email, 'password' => $password1, 'name' => $email]
                );
                if (Auth::loginUsingId($id)) {
                   return redirect()->intended('/user/');
                }
            }
        }
    }
}
[/code]

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/no-tfa/app/Http/Controllers/LogoutController.php">LogoutController.php</a>
[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Auth;
use App\Http\Requests;

class LogoutController extends Controller
{
    public function logout()
    {
        Auth::logout();
        return redirect()->intended('/');
    }
}
[/code]

&nbsp;

If you don't want to read over everything, you can just focus on the <em>IndexController</em>, here:

[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Auth;
use App\Http\Requests;

class IndexController extends Controller
{
    public function getIndex()
    {
        return view('index');
    }

    public function login(Request $request)
    {
        $email = strtolower($request->input('email'));
        $password = $request->input('password');
        $isAuthenticated = Auth::attempt(['email' => $email, 'password' => $password]);

        if (!$isAuthenticated) {
            return view('index', ['errorMessage' => 'Incorrect Email or Password']);
        } else {
            return redirect()->intended('/user/');
        }
    }
}
[/code]

If you're new to PHP or Laravel, here is what's going on in the code:

In the <a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/no-tfa/app/Http/routes.php">routes.php</a>, we configured function "getIndex" to handle GET requests  for '/' path, and function "login" to handle POST requests for the same path.

So, if it receives a GET request to this path '/', it will render the  page.

However, if it receives a POST request, it will response with a another logic. 

We check to see if the user or password are invalid using "Auth::attempt" function. If the user or password are not valid, then we display an error saying so. Otherwise, we log the user in.

You can see the full source on GitHub here: <a href="https://github.com/TwilioDevEd/blog-tfa-laravel/tree/no-tfa">https://github.com/TwilioDevEd/blog-tfa-laravel/tree/no-tfa</a>

<h3>Understanding TOTP</h3>
Before we get started with adding two-factor authentication to this example application, let's take a quick detour and to learn more about how TOTP works.

As you'll find on Wikipedia, <a href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">TOTP</a> "is an extension of the HMAC-based One Time Password algorithm HOTP to support a time based moving factor."

Based on that involved explanation, you might be surprised to find that generating a one time token with TOTP is not actually very complicated. Here is how you generate a 6 digit TOTP code:
<ol>
  <li>Compute the 20 byte HMAC of a "shared secret" and a timecode using HMAC-SHA1.</li>
  <li>Deterministically select an offset inside of that 20 byte HMAC.</li>
  <li>Starting at the offset, select a 4 byte range from the 20 byte HMAC.</li>
  <li>Turn the 4 byte range into an integer.</li>
  <li>Divide that integer by 1,000,000 (or "10**6", the "6" is the number of digits in the TOTP code)</li>
  <li>The remainder of that division is the 6 digit code - the TOTP code</li>
</ol>
If that isn't making sense, try taking a look at <a href="http://tools.ietf.org/html/rfc6238">RFC 6238</a> and this simple implementation of TOTP in PHP below.

<a href="https://github.com/ChristianRiesen/otp/blob/master/src/Otp.php">christian-riesen/otp lib</a>

[code language="php"]
#christian-riesen/otp
<?php

namespace Otp;

/**
 * One Time Passwords
 *
 * Implements HOTP and TOTP
 *
 * HMAC-Based One-time Password(HOTP) algorithm specified in RFC 4226
 * @link https://tools.ietf.org/html/rfc4226
 *
 * Time-based One-time Password (TOTP) algorithm specified in RFC 6238
 * @link https://tools.ietf.org/html/rfc6238
 *
 * As a note: This code is NOT 2038 proof! The min concern is the function
 * getBinaryCounter that uses the pack function which can't handle 64bit yet.
 *
 * Can be easy used with Google Authenticator
 * @link https://code.google.com/p/google-authenticator/
 *
 * @author Christian Riesen <chris.riesen@gmail.com>
 * @link http://christianriesen.com
 * @license MIT License see LICENSE file
 */

class Otp implements OtpInterface
{
    /**
     * The digits the code can have
     *
     * Either 6 or 8.
     * Authenticator does only support 6.
     *
     * @var integer
     */
    protected $digits = 6;
    
    /**
     * Time in seconds one counter period is long
     *
     * @var integer
     */
    protected $period = 30;
    
    /**
     * Possible algorithms
     *
     * @var array
     */
    protected $allowedAlgorithms = array('sha1', 'sha256', 'sha512');
    
    /**
     * Currently used algorithm
     *
     * @var string
     */
    protected $algorithm = 'sha1';
    
    /* (non-PHPdoc)
     * @see Otp.OtpInterface::hotp()
    */
    public function hotp($secret, $counter)
    {
        if (!is_numeric($counter) || $counter < 0) {
            throw new \InvalidArgumentException('Invalid counter supplied');
        }
        
        $hash = hash_hmac(
                $this->algorithm,
                $this->getBinaryCounter($counter),
                $secret,
                true
        );
    
        return str_pad($this->truncate($hash), $this->digits, '0', STR_PAD_LEFT);
    }
    
    /* (non-PHPdoc)
     * @see Otp.OtpInterface::totp()
    */
    public function totp($secret, $timecounter = null)
    {
        if (is_null($timecounter)) {
            $timecounter = $this->getTimecounter();
        }
    
        return $this->hotp($secret, $timecounter);
    }
    
    /* (non-PHPdoc)
     * @see Otp.OtpInterface::checkHotp()
    */
    public function checkHotp($secret, $counter, $key)
    {
        return $this->safeCompare($this->hotp($secret, $counter), $key);
    }


    /* (non-PHPdoc)
     * @see Otp.OtpInterface::checkHotpResync()
    */
    public function checkHotpResync($secret, $counter, $key, $counterwindow = 2)
    {
        if (!is_numeric($counter) || $counter < 0) {
            throw new \InvalidArgumentException('Invalid counter supplied');
        }

        if(!is_numeric($counterwindow) || $counterwindow < 0){
            throw new \InvalidArgumentException('Invalid counterwindow supplied');
        }

        for($c = 0; $c <= $counterwindow; $c = $c + 1) {
            if($this->safeCompare($this->hotp($secret, $counter + $c), $key)){
                return $counter + $c;
            }
        }
        return false;
    }
    
    /* (non-PHPdoc)
     * @see Otp.OtpInterface::checkTotp()
    */
    public function checkTotp($secret, $key, $timedrift = 1)
    {
        if (!is_numeric($timedrift) || $timedrift < 0) {
            throw new \InvalidArgumentException('Invalid timedrift supplied');
        }
        // Counter comes from time now
        // Also we check the current timestamp as well as previous and future ones
        // according to $timerange
        $timecounter = $this->getTimecounter();
    
        $start = $timecounter - ($timedrift);
        $end = $timecounter + ($timedrift);
    
        // We first try the current, as it is the most likely to work
        if ($this->safeCompare($this->totp($secret, $timecounter), $key)) {
            return true;
        } elseif ($timedrift == 0) {
            // When timedrift is 0, this is the end of the checks
            return false;
        }
    
        // Well, that didn't work, so try the others
        for ($t = $start; $t <= $end; $t = $t + 1) {
            if ($t == $timecounter) {
                // Already tried that one
                continue;
            }
                
            if ($this->safeCompare($this->totp($secret, $t), $key)) {
                return true;
            }
        }
    
        // if none worked, then return false
        return false;
    }
    
    /**
     * Changing the used algorithm for hashing
     *
     * Can only be one of the algorithms in the allowedAlgorithms property.
     *
     * @param string $algorithm
     * @throws \InvalidArgumentException
     * @return \Otp\Otp
     */
    
    /*
     * This has been disabled since it does not bring the expected results
     * according to the RFC test vectors for sha256 or sha512.
     * Until that is fixed, the algorithm simply stays at sha1.
     * Google Authenticator does not support sha256 and sha512 at the moment.
     *
    
    public function setAlgorithm($algorithm)
    {
        if (!in_array($algorithm, $this->allowedAlgorithms)) {
            throw new \InvalidArgumentException('Not an allowed algorithm: ' . $algorithm);
        }
        
        $this->algorithm = $algorithm;
        
        return $this;
    }
    // */
    
    /**
     * Get the algorithms name (lowercase)
     *
     * @return string
     */
    public function getAlgorithm()
    {
        return $this->algorithm;
    }
    
    /**
     * Setting period lenght for totp
     *
     * @param integer $period
     * @throws \InvalidArgumentException
     * @return \Otp\Otp
     */
    public function setPeriod($period)
    {
        if (!is_int($period)) {
            throw new \InvalidArgumentException('Period must be an integer');
        }
        
        $this->period = $period;
        
        return $this;
    }
    
    /**
     * Returns the set period value
     *
     * @return integer
     */
    public function getPeriod()
    {
        return $this->period;
    }
    
    /**
     * Setting number of otp digits
     *
     * @param integer $digits Number of digits for the otp (6 or 8)
     * @throws \InvalidArgumentException
     * @return \Otp\Otp
     */
    public function setDigits($digits)
    {
        if (!in_array($digits, array(6, 8))) {
            throw new \InvalidArgumentException('Digits must be 6 or 8');
        }
        
        $this->digits = $digits;
        
        return $this;
    }
    
    /**
     * Returns number of digits in the otp
     *
     * @return integer
     */
    public function getDigits()
    {
        return $this->digits;
    }
    
    /**
     * Generates a binary counter for hashing
     *
     * Warning: Not 2038 safe. Maybe until then pack supports 64bit.
     *
     * @param integer $counter Counter in integer form
     * @return string Binary string
     */
    private function getBinaryCounter($counter)
    {
        return pack('N*', 0) . pack('N*', $counter);
    }
    
    /**
     * Generating time counter
     *
     * This is the time divided by 30 by default.
     *
     * @return integer Time counter
     */
    private function getTimecounter()
    {
        return floor(time() / $this->period);
    }
    
    /**
     * Creates the basic number for otp from hash
     *
     * This number is left padded with zeros to the required length by the
     * calling function.
     *
     * @param string $hash hmac hash
     * @return number
     */
    private function truncate($hash)
    {
        $offset = ord($hash[19]) & 0xf;
        
        return (
            ((ord($hash[$offset+0]) & 0x7f) << 24 ) |
            ((ord($hash[$offset+1]) & 0xff) << 16 ) |
            ((ord($hash[$offset+2]) & 0xff) << 8 ) |
            (ord($hash[$offset+3]) & 0xff)
            ) % pow(10, $this->digits);
    }
    
    /**
     * Safely compares two inputs
     *
     * Assumed inputs are numbers and strings.
     * Compares them in a time linear manner. No matter how much you guess
     * correct of the partial content, it does not change the time it takes to
     * run the entire comparison.
     *
     * @param mixed $a
     * @param mixed $b
     * @return boolean
     */
    private function safeCompare($a, $b)
    {
        $sha1a = sha1($a);
        $sha1b = sha1($b);
        
        // Now the compare is always the same length. Even considering minute
        // time differences in sha1 creation, all you know is that a longer
        // input takes longer to hash, not how long the actual compared value is
        $result = 0;
        
        for ($i = 0; $i < 40; $i++) {
            $result |= ord($sha1a[$i]) ^ ord($sha1b[$i]);
        }
        
        return $result == 0;
    }
}
[/code]

&nbsp;

<h3>Adding Two-Factor Authentication</h3>
Now that you have a better understanding of how TOTP works, let's see how we would add it to the example web application that we started with. The first place that we'll be touching in our example above is the <i>IndexController</i>, here's what it looks like when it is modified to support logging in with two-factor authentication:

[code language="php"]
public function login(Request $request)
{
    $email = strtolower($request->input('email'));
    $password = $request->input('password');
    $isAuthenticated = Auth::once(['email' => $email, 'password' => $password]);

    if (!$isAuthenticated) {
        return view('index', ['errorMessage' => 'Incorrect Email or Password']);
    } else {
        $user = Auth::user();

        if ($user->enableTfaViaSms || $user->enableTfaViaApp) {
            $request->session()->put('tmp_user', $user);
            $request->session()->put('stage', 'password-validated');

            return redirect()->intended('/verify-tfa/');
        } else {
            // Add to session
            Auth::attempt(['email' => $email, 'password' => $password]);
            return redirect()->intended('/user/');
        }
        
    }
}
[/code]

This should all look very familiar, it's all the same code as before, with some modifications at the end.

Let's go over these modifications in a little more detail.

Here is the code that we started out with. No big changes here.

[code language="php"]
public function login(Request $request)
{
    $email = strtolower($request->input('email'));
    $password = $request->input('password');
    $isAuthenticated = Auth::attempt(['email' => $email, 'password' => $password]);

    if (!$isAuthenticated) {
        return view('index', ['errorMessage' => 'Incorrect Email or Password']);
    } else {
        return redirect()->intended('/user/');
    }
}
[/code]

Here is where we add our modifications. We start by checking to see if the user has one enabled two-factor authentication on their account via an app or SMS.

[code language="php"]
if ($user->enableTfaViaSms || $user->enableTfaViaApp) {
    $request->session()->put('tmp_user', $user);
    $request->session()->put('stage', 'password-validated');

    return redirect()->intended('/verify-tfa/');
} else {
    // Add to session
    Auth::attempt(['email' => $email, 'password' => $password]);
    return redirect()->intended('/user/');
}
[/code]

If TOTP is enabled, we record the fact that the user's password has been validated into the session state, and redirect the user's browser to "/verify-tfa".

Otherwise, if the user doesn't have any form of two-factor authentication enabled, then we just log them in as before.

In the case where the user has two-factor authentication enabled, they will be redirected to a page to enter in their two-factor authentication token. Here is what the code behind that page looks like:

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/master/app/Http/Controllers/VerifyTfaController.php">VerifyTfaController.php</a>
[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Twilio\Rest\Client;
use Otp\Otp;
use App\Http\Requests;
use Auth;
use DB;

class VerifyTfaController extends Controller
{
    public function verifyTfaPage(Request $request, Client $client, Otp $otp)
    {
        $user = $request->session()->get('tmp_user');
        if ($user->enableTfaViaSms) {
            $key = $otp->totp($user->totpSecret);

            $client->messages->create($user->phoneNumber,
              [
                  "from" => env('TWILIO_PHONE_NUMBER'),
                  "body" => 'Use this code to log in: ' . $key
              ]);
        }

        return view('verify-tfa', ['user' => $user]);
    }

    public function verifyTfa(Request $request, Otp $otp)
    {
        $user = $request->session()->get('tmp_user');

        if ($user == null) {
            return view('verify-tfa', ['errorMessage' => 'Error - no credentials']);
        } else if ($request->session()->get('stage') != 'password-validated') {
            return view('verify-tfa', ['errorMessage' => 'Password is not validated']);
        } else {
            $token = $request->input('token');
            if ($otp->checkTotp($user->totpSecret, $token)) {
                Auth::login($user);
                $request->session()->put('stage', 'logged-in');
                return redirect()->intended('/user/');
            } else {
                $errorMessage = 'There was an error verifying your token. Please try again.';
                return view('verify-tfa', ['errorMessage' => $errorMessage]);
            }
        }
    }
}
[/code]

And here's what that code does. Again, we have the "verifyTfaPage" that handles GET requests to "/verify-tfa" path. When it receives it, then we send the user an SMS with their token (if they have that configured) and then render the page prompting the user to enter their token.

[code language="php"]
public function verifyTfaPage(Request $request, Client $client, Otp $otp)
{
    $user = $request->session()->get('tmp_user');
    if ($user->enableTfaViaSms) {
        $key = $otp->totp($user->totpSecret);

        $client->messages->create($user->phoneNumber,
          [
              "from" => env('TWILIO_PHONE_NUMBER'),
              "body" => 'Use this code to log in: ' . $key
          ]);
    }

    return view('verify-tfa', ['user' => $user]);
}
[/code]

To handle POST request, first it finds the user by username, and delegates the response to a callback. It does some sanity checking on the session data. We should never actually get into a state where this code will run, it's here Just In Case.

[code language="php"]
public function verifyTfa(Request $request, Otp $otp)
{
    $user = $request->session()->get('tmp_user');

    if ($user == null) {
        return view('verify-tfa', ['errorMessage' => 'Error - no credentials']);
    } else if ($request->session()->get('stage') != 'password-validated') {
        return view('verify-tfa', ['errorMessage' => 'Password is not validated']);
    } else {
        $token = $request->input('token');
        if ($otp->checkTotp($user->totpSecret, $token)) {
            Auth::login($user);
            $request->session()->put('stage', 'logged-in');
            return redirect()->intended('/user/');
        } else {
            $errorMessage = 'There was an error verifying your token. Please try again.';
            return view('verify-tfa', ['errorMessage' => $errorMessage]);
        }
    }
}
[/code]

If we reach out to the else statement, we check if that token is valid for the user. If it is, log the user in and send them to their user page! Otherwise, we ask the user to enter their token again.

<h3>Adding Google Authenticator</h3>
Now that we have code to add TOTP authentication to the login process, let's take a look at how we'll get our users to enable TOTP authentication on their account.

Keep in mind that you don't have to use Google Authenticator for this to work. TOTP is an IETF standard and has many different <a href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm#Client_Implementations">client implementations</a>.

I'm using Google Authenticator in this example because it seems to be the most widely used TOTP client at this time. Let's get started.

Here is the basic overview of how this part works:
<ul>
  <li>The user visits a page to add Google Authenticator to their account.</li>
  <li>The page contains a QR code that the user scans with Google Authenticator.</li>
  <li>After scanning the QR code, the user will enter the 6 digit token that Google Authenticator displays</li>
</ul>
This is what the page will look like: <img src="http://www.twilio.com/blog/wp-content/uploads/2013/04/enable-google-authenticator.png" alt="" />

And here is the code that handles takes the 6 digit token and adds it to the user's account.

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/master/app/Http/Controllers/EnableTfaViaAppController.php">EnableTfaViaAppController.php</a>

[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Auth;
use Otp\Otp;
use App\Http\Requests;

class EnableTfaViaAppController extends Controller
{
    public function enableTfaViaAppPage()
    {
        return view('enable-tfa-via-app');
    }

    public function enableTfaViaApp(Request $request, Otp $otp)
    {
        $token = $request->input('token');
        $user = Auth::user();
        if ($token != null && $otp->checkTotp($user->totpSecret, $token)) {
            $user->enableTfaViaApp = true;
            $user->save();
            return view('enable-tfa-via-app');
        } else {
            $errorMessage = 'There was an error verifying your token. Please try again.';
            return view('enable-tfa-via-app', ['errorMessage' => $errorMessage]);
        }
        return view('enable-tfa-via-app'); 
    }
}
[/code]

By this point, you should be familiar with the first part of this function.

Starting on the <i>if</i> statement, we check to see if the token that the user entered is valid, this is an important step that makes sure that the user set up Google Authenticator correctly.

Once we know that the token is valid, we update a flag on the user's account and save the update. The details of how this data is persisted will differ from application to application, so we don't cover those details in this tutorial.

If there was an error with the token, notify the user and ask them to try again.

Finally, I wanted to show you how I generate the QR code. I'm generating my own QR code to avoid sending the shared secret to another service and reduce the risk of leaking the shared secret in a plaintext string.

Each account in Google Authenticator has an account name, so in this section we create a globally unique name for our user and then have our totp object make us an image with the QR code that will contain that account name and the TOTP shared secret for that account.

When we call "qr.image()" method, it generates the code object, and then we set the content type and call the "pipe" method to writing the qr code content in the response.

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/master/resources/views/auth-qr-code.php">views/auth-qr-code.php</a>
[code language="php"]
<?php
  header('Content-Type: image/png');
  echo QrCode::format('png')->size(300)->generate($otpauthUrl);
  exit;
?>
[/code]

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/master/app/Http/Controllers/AuthQrCodeController.php">AuthQrCodeController.php</a>

[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Otp\GoogleAuthenticator;
use App\Http\Requests;
use Auth;
use Base32\Base32;

class AuthQrCodeController extends Controller
{
    public function qrcode()
    {
        $user = Auth::user();
        $label = $user->email;
        $secret = $user->totpSecret;
        $otpauthUrl = 'otpauth://totp/' . $label .'?secret=' . Base32::encode($secret);

        return view('auth-qr-code', ['otpauthUrl' => $otpauthUrl]);
    }
    
}
[/code]

As I noted earlier, I'm glossing over several things here. I'm not showing you how I persist the user objects and I'm not showing you the HTML that gets sent to the user. If you're wondering what those look like, take a look at the full source over here: <a href="https://github.com/TwilioDevEd/blog-tfa-laravel">https://github.com/TwilioDevEd/blog-tfa-laravel</a>

<h3>Adding Twilio</h3>
Once we've added support for Google Authenticator, it's just a small additional step to give our users the ability to receive TOTP tokens on their phones via SMS. The procedure for adding SMS based two-factor authentication is very similar to adding support for Google Authenticator. The main difference is that instead of having our users scan a QR code, we have them enter in their mobile phone number.

Here is what this page looks like:
<img src="http://www.twilio.com/blog/wp-content/uploads/2013/04/enable-twilio-sms.png" alt="" />

And here is the code that powers the page above.

<a href="https://github.com/TwilioDevEd/blog-tfa-laravel/blob/master/app/Http/Controllers/EnableTfaViaSmsController.php">EnableTfaViaSmsController.php</a>
[code language="php"]
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Auth;
use DB;
use App\Http\Requests;
use Twilio\Rest\Client;
use Otp\Otp;

class EnableTfaViaSmsController extends Controller
{
    public function enableTfaViaSmsPage()
    {
        return view('enable-tfa-via-sms');
    }

    public function enableTfaViaSms(Request $request, Client $client, Otp $otp)
    {
        $phoneNumber = $request->input('phoneNumber');
        $token = $request->input('token');
        $user = Auth::user();
        
        if ($phoneNumber != null) {
            $user->phoneNumber = $phoneNumber;
            $user->save();

            $key = $otp->totp($user->totpSecret);

            $client->messages->create($user->phoneNumber,
              [
                  "from" => env('TWILIO_PHONE_NUMBER'),
                  "body" => 'Use this code to log in: ' . $key
              ]);

            $successMessage = 'An SMS has been sent to the '
                . 'phone number you entered. When you get the SMS, enter the code in the SMS where '
                . 'it says "Enter your verification code" below.';

            return view('enable-tfa-via-sms', ['successMessage' => $successMessage]);
        } else if ($token != null && $otp->checkTotp($user->totpSecret, $token)) {
            $user->enableTfaViaSms = true;
            $user->save();

            $successMessage = 'You are set up for Two-Factor Authentication via Twilio SMS!';
            return view('enable-tfa-via-sms', ['successMessage' => $successMessage]);
        } else {
            $errorMessage = 'There was an error verifying your token. Please try again.';
            return view('enable-tfa-via-sms', ['errorMessage' => $errorMessage]);
        }
    }
}
[/code]

In this code, we check to see if we got a phone number in the "POST" request.

If so, we take the phone number and send an SMS with the TOTP code to that phone number.

Assuming that previous section of code worked, the user should have received an SMS with their TOTP code and then entered that code into the page. In this part of the code, we check to see if we were give a token and see if that token is valid. If the token is valid, we enable two-factor authentication for this account and save that setting. As I said in the section on adding Google Authenticator, the details of how to persist the user settings will be unique to your situation, so I don't cover that here. If there was an error validating the token, then we notify the user of that error via a flag that will be checked by our HTML template.

<h3>Summary</h3>
In this article, we showed you an example of a simple web application written in PHP/Laravel. We showed you how to add two-factor authentication to that application, Finally, we showed you how you would enable your users to use Google Authenticator or SMS to authenticate to that modified application.

What I didn't cover is the HTML that I used in this example or how I saved the user data.

To really understand what is going on, I suggest that you try out the example I have running online and then look at the code.
<h3>Try it out yourself</h3>
If you want to see what this all looks like, here is a copy of the code running online for you to try out: <a href="http://twilio-tfa.herokuapp.com">http://twilio-tfa.herokuapp.com</a>

All of the source code for this example is also available on GitHub: <a href="https://github.com/TwilioDevEd/blog-tfa-laravel">https://github.com/TwilioDevEd/blog-tfa-laravel</a>

Thanks for reading.

Please let me know if you have any additional questions, feedback or patches.